@article{kernelfarer,
author = {De Carvalho, Jo\~{a}o P. L. and Kuzma, Braedy and Korostelev, Ivan and Amaral, Jos\'{e} Nelson and Barton, Christopher and Moreira, Jos\'{e} and Araujo, Guido},
title = {KernelFaRer: Replacing Native-Code Idioms with High-Performance Library Calls},
year = {2021},
issue_date = {September 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {18},
number = {3},
issn = {1544-3566},
url = {https://doi.org/10.1145/3459010},
doi = {10.1145/3459010},
abstract = {Well-crafted libraries deliver much higher performance than code generated by sophisticated application programmers using advanced optimizing compilers. When a code pattern for which a well-tuned library implementation exists is found in the source code of an application, the highest performing solution is to replace the pattern with a call to the library. Idiom-recognition solutions in the past either required pattern matching machinery that was outside of the compilation framework or provided a very brittle solution that would fail even for minor variants in the pattern source code. This article introduces Kernel Find \& Replacer (KernelFaRer), an idiom recognizer implemented entirely in the existing LLVM compiler framework. The versatility of KernelFaRer is demonstrated by matching and replacing two linear algebra idioms, general matrix-matrix multiplication (GEMM), and symmetric rank-2k update (SYR2K). Both GEMM and SYR2K are used extensively in scientific computation, and GEMM is also a central building block for deep learning and computer graphics algorithms. The idiom recognition in KernelFaRer is much more robust than alternative solutions, has a much lower compilation overhead, and is fully integrated in the broadly used LLVM compilation tools. KernelFaRer replaces existing GEMM and SYR2K idioms with computations performed by BLAS, Eigen, MKL (Intel’s x86), ESSL (IBM’s PowerPC), and BLIS (AMD). Gains in performance that reach 2000\texttimes{} over hand-crafted source code compiled at the highest optimization level demonstrate that replacing application code with library call is a performant solution.},
journal = {ACM Trans. Archit. Code Optim.},
month = {jun},
articleno = {38},
numpages = {22},
keywords = {GEMM, Idiom recognition, LLVM, compiler analysis and transformations}
}

@inproceedings{IDL,
author = {Ginsbach, Philip and Remmelg, Toomas and Steuwer, Michel and Bodin, Bruno and Dubach, Christophe and O'Boyle, Michael F. P.},
title = {Automatic Matching of Legacy Code to Heterogeneous APIs: An Idiomatic Approach},
year = {2018},
isbn = {9781450349116},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3173162.3173182},
doi = {10.1145/3173162.3173182},
abstract = {Heterogeneous accelerators often disappoint. They provide the prospect of great performance, but only deliver it when using vendor specific optimized libraries or domain specific languages. This requires considerable legacy code modifications, hindering the adoption of heterogeneous computing. This paper develops a novel approach to automatically detect opportunities for accelerator exploitation. We focus on calculations that are well supported by established APIs: sparse and dense linear algebra, stencil codes and generalized reductions and histograms. We call them idioms and use a custom constraint-based Idiom Description Language (IDL) to discover them within user code. Detected idioms are then mapped to BLAS libraries, cuSPARSE and clSPARSE and two DSLs: Halide and Lift. We implemented the approach in LLVM and evaluated it on the NAS and Parboil sequential C/C++ benchmarks, where we detect 60 idiom instances. In those cases where idioms are a significant part of the sequential execution time, we generate code that achieves 1.26x to over 20x speedup on integrated and external GPUs.},
booktitle = {Proceedings of the Twenty-Third International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {139–153},
numpages = {15},
keywords = {computer systems organization},
location = {Williamsburg, VA, USA},
series = {ASPLOS '18}
}

@inproceedings{ATC,
author = {Mart\'{\i}nez, Pablo Antonio and Woodruff, Jackson and Armengol-Estap\'{e}, Jordi and Bernab\'{e}, Gregorio and Garc\'{\i}a, Jos\'{e} Manuel and O’Boyle, Michael F. P.},
title = {Matching Linear Algebra and Tensor Code to Specialized Hardware Accelerators},
year = {2023},
isbn = {9798400700880},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3578360.3580262},
doi = {10.1145/3578360.3580262},
abstract = {Dedicated tensor accelerators demonstrate the importance of linear algebra in modern applications. Such accelerators have the potential for impressive performance gains, but require programmers to rewrite code using vendor APIs - a barrier to wider scale adoption. Recent work overcomes this by matching and replacing patterns within code, but such approaches are fragile and fail to cope with the diversity of real-world codes.  

We develop ATC, a compiler that uses program synthesis to map regions of code to specific APIs. The mapping space that ATC explores is combinatorially large, requiring the development of program classification, dynamic analysis, variable constraint generation and lexical distance matching techniques to make it tractable.  

We apply ATC to real-world tensor and linear algebra codes and evaluate them against four state-of-the-art approaches. We accelerate between 2.6x and 7x more programs, leading to over an order of magnitude performance improvement.},
booktitle = {Proceedings of the 32nd ACM SIGPLAN International Conference on Compiler Construction},
pages = {85–97},
numpages = {13},
keywords = {Program synthesis, Offloading, LLVM, GEMM},
location = {Montr\'{e}al, QC, Canada},
series = {CC 2023}
}

@inproceedings{cummins2021a,
  title={{ProGraML: A Graph-based Program Representation for Data Flow Analysis and Compiler Optimizations}},
  author={Cummins, Chris and Fisches, Zacharias and Ben-Nun, Tal and Hoefler, Torsten and O'Boyle, Michael and Leather, Hugh},
  booktitle = {Thirty-eighth International Conference on Machine Learning (ICML)},
  year={2021}
}


@INPROCEEDINGS{graphlily,  author={Hu, Yuwei and Du, Yixiao and Ustun, Ecenur and Zhang, Zhiru},  booktitle={2021 IEEE/ACM International Conference On Computer Aided Design (ICCAD)},   title={GraphLily: Accelerating Graph Linear Algebra on HBM-Equipped FPGAs},   year={2021},  volume={},  number={},  pages={1-9},  doi={10.1109/ICCAD51958.2021.9643582}}

@inproceedings{hisparse,
	author = {Du, Yixiao and Hu, Yuwei and Zhou, Zhongchun and Zhang, Zhiru},
	year = {2022},
	month = {02},
	pages = {54-64},
	title = {High-Performance Sparse Linear Algebra on HBM-Equipped FPGAs Using HLS: A Case Study on SpMV},
	doi = {10.1145/3490422.3502368}
}

@inproceedings{serpens,
	author = {Song, Linghao and Chi, Yuze and Guo, Licheng and Cong, Jason},
	title = {Serpens: a high bandwidth memory based accelerator for general-purpose sparse matrix-vector multiplication},
	year = {2022},
	isbn = {9781450391429},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3489517.3530420},
	doi = {10.1145/3489517.3530420},
	booktitle = {Proceedings of the 59th ACM/IEEE Design Automation Conference},
	pages = {211–216},
	numpages = {6},
	location = {San Francisco, California},
	series = {DAC '22}
}

@INPROCEEDINGS{fccm-spmv,
  author={Jain, Abhishek Kumar and Ravishankar, Chirag and Omidian, Hossein and Kumar, Sharan and Kulkarni, Maithilee and Tripathi, Aashish and Gaitonde, Dinesh},
  booktitle={2023 IEEE 31st Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM)}, 
  title={Modular and Lean Architecture with Elasticity for Sparse Matrix Vector Multiplication on FPGAs}, 
  year={2023},
  volume={},
  number={},
  pages={133-143},
  keywords={Performance evaluation;Architecture;Computer architecture;Bandwidth;Elasticity;Fabrics;Timing;n/a},
  doi={10.1109/FCCM57271.2023.00023}}

@inproceedings{autobridge,
	author = {Guo, Licheng and Chi, Yuze and Wang, Jie and Lau, Jason and Qiao, Weikang and Ustun, Ecenur and Zhang, Zhiru and Cong, Jason},
	year = {2021},
	month = {02},
	pages = {81-92},
	title = {AutoBridge: Coupling Coarse-Grained Floorplanning and Pipelining for High-Frequency HLS Design on Multi-Die FPGAs},
	volume = {2021},
	journal = {FPGA. ACM International Symposium on Field-Programmable Gate Arrays},
	doi = {10.1145/3431920.3439289}
}

@inproceedings{10.1145/1542476.1542516,
	author = {Ravitch, Tristan and Jackson, Steve and Aderhold, Eric and Liblit, Ben},
	title = {Automatic generation of library bindings using static analysis},
	year = {2009},
	isbn = {9781605583921},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/1542476.1542516},
	doi = {10.1145/1542476.1542516},
	abstract = {High-level languages are growing in popularity. However, decades of C software development have produced large libraries of fast, time-tested, meritorious code that are impractical to recreate from scratch. Cross-language bindings can expose low-level C code to high-level languages. Unfortunately, writing bindings by hand is tedious and error-prone, while mainstream binding generators require extensive manual annotation or fail to offer the language features that users of modern languages have come to expect.We present an improved binding-generation strategy based on static analysis of unannotated library source code. We characterize three high-level idioms that are not uniquely expressible in C's low-level type system: array parameters, resource managers, and multiple return values. We describe a suite of interprocedural analyses that recover this high-level information, and we show how the results can be used in a binding generator for the Python programming language. In experiments with four large C libraries, we find that our approach avoids the mistakes characteristic of hand-written bindings while offering a level of Python integration unmatched by prior automated approaches. Among the thousands of functions in the public interfaces of these libraries, roughly 40\% exhibit the behaviors detected by our static analyses.},
	booktitle = {Proceedings of the 30th ACM SIGPLAN Conference on Programming Language Design and Implementation},
	pages = {352–362},
	numpages = {11},
	keywords = {bindings, dataflow analysis, ffi, foreign function interfaces, multi-language code reuse, static library analysis},
	location = {Dublin, Ireland},
	series = {PLDI '09}
}

@article{static,
	author = {Ravitch, Tristan and Jackson, Steve and Aderhold, Eric and Liblit, Ben},
	title = {Automatic generation of library bindings using static analysis},
	year = {2009},
	issue_date = {June 2009},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {44},
	number = {6},
	issn = {0362-1340},
	url = {https://doi.org/10.1145/1543135.1542516},
	doi = {10.1145/1543135.1542516},
	abstract = {High-level languages are growing in popularity. However, decades of C software development have produced large libraries of fast, time-tested, meritorious code that are impractical to recreate from scratch. Cross-language bindings can expose low-level C code to high-level languages. Unfortunately, writing bindings by hand is tedious and error-prone, while mainstream binding generators require extensive manual annotation or fail to offer the language features that users of modern languages have come to expect.We present an improved binding-generation strategy based on static analysis of unannotated library source code. We characterize three high-level idioms that are not uniquely expressible in C's low-level type system: array parameters, resource managers, and multiple return values. We describe a suite of interprocedural analyses that recover this high-level information, and we show how the results can be used in a binding generator for the Python programming language. In experiments with four large C libraries, we find that our approach avoids the mistakes characteristic of hand-written bindings while offering a level of Python integration unmatched by prior automated approaches. Among the thousands of functions in the public interfaces of these libraries, roughly 40\% exhibit the behaviors detected by our static analyses.},
	journal = {SIGPLAN Not.},
	month = {jun},
	pages = {352–362},
	numpages = {11},
	keywords = {bindings, dataflow analysis, ffi, foreign function interfaces, multi-language code reuse, static library analysis}
}

@INPROCEEDINGS{autodok,
	author={Iskandar, Veronia and Abd El Ghany, Mohamed A. and Goehringer, Diana},
	booktitle={2023 26th Euromicro Conference on Digital System Design (DSD)}, 
	title={Auto-DOK: Compiler-Assisted Automatic Detection of Offload Kernels for FPGA-HBM Architectures}, 
	year={2023},
	volume={},
	number={},
	pages={577-584},
	keywords={Systematics;Program processors;Random access memory;Machine learning;Parallel processing;Hardware;Distance measurement;Parallel Architectures;High-bandwidth Memory (HBM);Code Characterization},
	doi={10.1109/DSD60849.2023.00085}}

@INPROCEEDINGS{gpu-dense,
	author={Brown, Cade and Abdelfattah, Ahmad and Tomov, Stanimire and Dongarra, Jack},
	booktitle={2020 IEEE High Performance Extreme Computing Conference (HPEC)}, 
	title={Design, Optimization, and Benchmarking of Dense Linear Algebra Algorithms on AMD GPUs}, 
	year={2020},
	volume={},
	number={},
	pages={1-7},
	keywords={Linear systems;Linear algebra;Benchmark testing;Tools;Software;Numerical models;Hip;Numerical Linear Algebra;HPC;GPU Computing;AMD GPUs;HIP Runtime;Portability},
	doi={10.1109/HPEC43674.2020.9286214}}

@misc{Xilinx2021,
	author       = {Xilinx},
	title        = {Vitis Sparse Library},
	howpublished = {\url{https://xilinx.github.io/Vitis_Libraries/sparse/2021.1/overview.html}},
	year         = {2021}
}

@inproceedings{ogb,
	author = {Hu, Weihua and Fey, Matthias and Zitnik, Marinka and Dong, Yuxiao and Ren, Hongyu and Liu, Bowen and Catasta, Michele and Leskovec, Jure},
	title = {Open graph benchmark: datasets for machine learning on graphs},
	year = {2020},
	isbn = {9781713829546},
	publisher = {Curran Associates Inc.},
	address = {Red Hook, NY, USA},
	abstract = {We present the OPEN GRAPH BENCHMARK (OGB), a diverse set of challenging and realistic benchmark datasets to facilitate scalable, robust, and reproducible graph machine learning (ML) research. OGB datasets are large-scale, encompass multiple important graph ML tasks, and cover a diverse range of domains, ranging from social and information networks to biological networks, molecular graphs, source code ASTs, and knowledge graphs. For each dataset, we provide a unified evaluation protocol using meaningful application-specific data splits and evaluation metrics. In addition to building the datasets, we also perform extensive benchmark experiments for each dataset. Our experiments suggest that OGB datasets present significant challenges of scalability to large-scale graphs and out-of-distribution generalization under realistic data splits, indicating fruitful opportunities for future research. Finally, OGB provides an automated end-to-end graph ML pipeline that simplifies and standardizes the process of graph data loading, experimental setup, and model evaluation. OGB will be regularly updated and welcomes inputs from the community.},
	booktitle = {Proceedings of the 34th International Conference on Neural Information Processing Systems},
	articleno = {1855},
	numpages = {16},
	location = {Vancouver, BC, Canada},
	series = {NIPS '20}
}

@inproceedings{transformer,
	author = {Vaswani, Ashish and Shazeer, Noam and Parmar, Niki and Uszkoreit, Jakob and Jones, Llion and Gomez, Aidan N. and Kaiser, \L{}ukasz and Polosukhin, Illia},
	title = {Attention is all you need},
	year = {2017},
	isbn = {9781510860964},
	publisher = {Curran Associates Inc.},
	address = {Red Hook, NY, USA},
	abstract = {The dominant sequence transduction models are based on complex recurrent or convolutional neural networks that include an encoder and a decoder. The best performing models also connect the encoder and decoder through an attention mechanism. We propose a new simple network architecture, the Transformer, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely. Experiments on two machine translation tasks show these models to be superior in quality while being more parallelizable and requiring significantly less time to train. Our model achieves 28.4 BLEU on the WMT 2014 English-to-German translation task, improving over the existing best results, including ensembles, by over 2 BLEU. On the WMT 2014 English-to-French translation task, our model establishes a new single-model state-of-the-art BLEU score of 41.0 after training for 3.5 days on eight GPUs, a small fraction of the training costs of the best models from the literature.},
	booktitle = {Proceedings of the 31st International Conference on Neural Information Processing Systems},
	pages = {6000–6010},
	numpages = {11},
	location = {Long Beach, California, USA},
	series = {NIPS'17}
}

@article{Goto,
	author = {Goto, Kazushige and Geijn, Robert A. van de},
	title = {Anatomy of high-performance matrix multiplication},
	year = {2008},
	issue_date = {May 2008},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {34},
	number = {3},
	issn = {0098-3500},
	url = {https://doi.org/10.1145/1356052.1356053},
	doi = {10.1145/1356052.1356053},
	abstract = {We present the basic principles that underlie the high-performance implementation of the matrix-matrix multiplication that is part of the widely used GotoBLAS library. Design decisions are justified by successively refining a model of architectures with multilevel memories. A simple but effective algorithm for executing this operation results. Implementations on a broad selection of architectures are shown to achieve near-peak performance.},
	journal = {ACM Trans. Math. Softw.},
	month = {may},
	articleno = {12},
	numpages = {25},
	keywords = {Linear algebra, basic linear algebra subprogrms, matrix multiplication}
}

@article{STRASSEN1969,
	author = {STRASSEN, V.},
	journal = {Numerische Mathematik},
	keywords = {numerical analysis},
	pages = {354-356},
	title = {Gaussian Elimination is not Optimal.},
	url = {http://eudml.org/doc/131927},
	volume = {13},
	year = {1969},
}

@inproceedings{facc,
	author = {Woodruff, Jackson and Armengol-Estap\'{e}, Jordi and Ainsworth, Sam and O'Boyle, Michael F. P.},
	title = {Bind the gap: compiling real software to hardware FFT accelerators},
	year = {2022},
	isbn = {9781450392655},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	url = {https://doi.org/10.1145/3519939.3523439},
	doi = {10.1145/3519939.3523439},
	abstract = {Specialized hardware accelerators continue to be a source of performance improvement. However, such specialization comes at a programming price. The fundamental issue is that of a mismatch between the diversity of user code and the functionality of fixed hardware, limiting its wider uptake. Here we focus on a particular set of accelerators: those for Fast Fourier Transforms. We present FACC (Fourier ACcelerator Compiler), a novel approach to automatically map legacy code to Fourier Transform accelerators. It automatically generates drop-in replacement adapters using Input-Output (IO)-based program synthesis that bridge the gap between user code and accelerators. We apply FACC to unmodified GitHub C programs of varying complexity and compare against two existing approaches. We target FACC  
	to a high-performance library, FFTW, and two hardware accelerators, the NXP PowerQuad and the Analog Devices FFTA, and demonstrate mean speedups of 9x, 17x and 27x respectively},
	booktitle = {Proceedings of the 43rd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
	pages = {687–702},
	numpages = {16},
	keywords = {FFT, hardware accelerator, program synthesis},
	location = {San Diego, CA, USA},
	series = {PLDI 2022}
}

@INPROCEEDINGS{tapa,
	author={Chi, Yuze and Guo, Licheng and Lau, Jason and Choi, Young-kyu and Wang, Jie and Cong, Jason},
	booktitle={2021 IEEE 29th Annual International Symposium on Field-Programmable Custom Computing Machines (FCCM)}, 
	title={Extending High-Level Synthesis for Task-Parallel Programs}, 
	year={2021},
	volume={},
	number={},
	pages={204-213},
	keywords={Productivity;Semantics;C++ languages;Tools;Programming;Task analysis;Kernel},
	doi={10.1109/FCCM51124.2021.00032}}
